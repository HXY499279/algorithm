## [1. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```javascript
/**
 * Your CQueue object will be instantiated and called as such:
 * var obj = new CQueue()
 * obj.appendTail(value)
 * var param_2 = obj.deleteHead()
 */
var CQueue = function () {
  this.stack1 = [];
  this.stack2 = [];
};

/**
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function (value) {
  this.stack1.push(value);
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function () {
  if (!this.stack2.length) {
    while (this.stack1.length) {
      this.stack2.push(this.stack1.pop());
    }
  }
  if (!this.stack2.length) {
    return -1;
  } else {
    return this.stack2.pop();
  }
};
/* 
  维护两个栈，第一个栈用于插入元素，第二个栈用于删除元素。
  往队列中添加元素的时候，直接在栈1内push元素
  删除队列首元素时
  - 判断栈2内是否有元素，栈2中无元素时，要将栈1内的元素pop出来再push进栈2
  - 再判断栈2内是否有元素，栈2中有元素时，不能将栈1内元素拿过来，可以直接pop删除，无元素时返回-1
*/
```

![用双栈实现队列动态图](https://assets.leetcode-cn.com/solution-static/jianzhi_09/jianzhi_9.gif)

> 图片作者：LeetCode-Solution https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/

## [2. 包含 min 函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

```javascript
/**
 * initialize your data structure here.
 */

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.min()
 */
var MinStack = function () {
  this.A = [];
  this.B = [];
  this.A.peek = () => this.A[this.A.length - 1];
  this.B.peek = () => this.B[this.B.length - 1];
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function (x) {
  this.A.push(x);
  !this.B.length || this.B.peek() >= x ? this.B.push(x) : 0;
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function () {
  this.B.peek() === this.A.pop() && this.B.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function () {
  return this.A.peek();
};

/**
 * @return {number}
 */
MinStack.prototype.min = function () {
  return this.B.peek();
};
/* 
  将min()的复杂度从O(n)降至O(1)
  栈B存储栈A中非严格降序的元素
   - 将栈A的栈底元素作为栈B的栈底元素（同时也是栈B中最大的元素）
   - 如果栈A中新压入栈的元素等于或小于栈B的栈底元素，则也压入栈B
  这样就保证了栈B的栈顶元素就是栈A中的最小元素

  重点设计push和pop函数
  - push函数
    1. 将x压入栈A
    2. 判断栈B为空或者x小于等于栈B的栈顶元素时，将X压入栈B
  - pop函数
    1. 将y移出栈A
    2. 判断y是否等于栈B的栈顶元素，若等于，则执行栈B的栈顶元素出栈
*/
```

![栈A与辅助栈B的关系](https://pic.leetcode-cn.com/f31f4b7f5e91d46ea610b6685c593e12bf798a9b8336b0560b6b520956dd5272-Picture1.png)

> 图片作者：jyd https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/

## [3. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

```javascript
/**
 * initialize your data structure here.
 */

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {number[]}
 */
var reversePrint = function (head) {
  let len = 0,
    curNode = head,
    retArr = [];
  while (curNode) {
    len++, (curNode = curNode.next);
  }
  curNode = head;
  for (let i = len - 1; i >= 0; i--) {
    retArr[i] = curNode.val;
    curNode = curNode.next;
  }
  return retArr;
};
/*
 */
```

## [4. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  let preNode = null,
    curNode = head;
  while (curNode) {
    let next = curNode.next;
    curNode.next = preNode;
    preNode = curNode;
    curNode = next;
  }
  return preNode;
};
/*
 */
```

## [5. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

```javascript
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function (head) {
  if (head == null) return null;
  let map = new Map(),
    cur = head;
  while (cur) {
    // 给每一个节点生成对应的一个新节点，形成节点和新节点的对应
    map.set(cur, new Node(cur.val));
    cur = cur.next;
  }
  cur = head;
  while (cur) {
    // 通过旧节点映射的新节点，新节点按照旧节点的关系进行连接
    map.get(cur).next = map.get(cur.next) || null;
    map.get(cur).random = map.get(cur.random);
    cur = cur.next;
  }
  return map.get(head);
};
/*
  算法流程：
    1. 判断head节点是否为null，为null直接返回null
    2. 初始化一个map结构（建立旧节点和新节点的映射），初始化一个cur指向当前节点
    3. 建立新旧节点的映射，map.set(cur, new Node(cur.val))
    4. 根据旧节点的next random关系，构建新节点的next和random关系
    5. 返回新链表的头节点
 */
```

```javascript
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function (head) {
  if (head == null) return null;
  let cur = head;
  while (cur) {
    let newNode = new Node(cur.val);
    newNode.next = cur.next;
    cur.next = newNode;
    cur = newNode.next;
  }
  cur = head;
  while (cur) {
    cur.random && (cur.next.random = cur.random.next);
    cur = cur.next.next;
  }
  cur = head.next;
  let pre = head,
    res = cur;
  while (cur.next) {
    pre.next = pre.next.next;
    cur.next = cur.next.next;
    pre = pre.next;
    cur = cur.next;
  }
  pre.next = null;
  return res;
};
/*
  算法流程：
    1. 制造复制节点，并拼接在原节点后
     - node1 -> node2 -> node3 ......
     - node1 -> node1new -> node2 -> node2new ......
    2. 构建新节点的random指向
     - 根据原节点的random指向，将新节点（cur.next）的random指向改为cur.random.next
    3. 拆分原/新链表
     - 设置 pre / cur 分别指向原 / 新链表头节点，遍历执行 pre.next = pre.next.next 和 cur.next = cur.next.next 将两链表拆分开。
    4. 返回新链表的头节点 res 即可。
 */
```
