## [1. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
  const map = new Map();
  for (let num of nums) {
    map.set(num, map.has(num) ? map.get(num) + 1 : 1);
  }
  return map.get(target) || 0;
};
/*
  使用map结构来记录数字在数组中出现的次数
 */
```

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
  let i = 0,
    j = nums.length - 1;
  while (i <= j) {
    let m = Math.floor((i + j) / 2);
    nums[m] <= target ? (i = m + 1) : (j = m - 1);
  }
  let right = i;
  if (j >= 0 && nums[j] !== target) return 0;
  i = 0;
  while (i <= j) {
    let m = Math.floor((i + j) / 2);
    nums[m] >= target ? (j = m - 1) : (i = m + 1);
  }
  let left = j;
  return right - left - 1;
};
/*
  题解：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/
  解题思路： 
    （无序数组先将数组排序），排序数组nums中的所有数字target形成一个窗口，记窗口的左/右边界索引分别为left和right。
    分别对应窗口左边/右边的首个元素。本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 left 
    和 右边界 right ，易得数字 target 的数量为 right - left - 1right−left−1 。
 */
```

## [2. 0 ～ n-1 中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function (nums) {
  let i = 0,
    j = nums.length - 1;
  while (i <= j) {
    let m = Math.floor((i + j) / 2);
    nums[m] === m ? (i = m + 1) : (j = m - 1);
  }
  return i;
};
/*
  题解：https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/
  解题思路： 
    - 排序数组的搜索问题首先想到二分法
    - 根据题意，范围为0~n-1内的n个数字，说明索引和值有对应关系，可以将数组划分为两部分
      左子数组：nums[i] = i;
      右子数组：nums[i] !== i;
      所以缺失的数字就是右子数组的首元素对应的索引
      因此用二分法查找右子数组的首位元素
 */
```

## [3. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

```javascript
/**
 * @param {string} s
 * @return {character}
 */
var firstUniqChar = function (s) {
    const map = new Map()
    for (let c of s) {
        map.set(c, !map.has(c))
    }
    for (let [k, v] of map.entries()) {
        if (v) return k
    }
    return ' '
};
/*
  题解：https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/
  解题思路： 
    遍历字符串 s ，使用哈希表统计各字符出现的次数，出现一次的为true，出现大于1次为false。
    再遍历字符串 s ，在哈希表中找到首个 “出现次数为 1 的字符”，并返回，否则返回' '
 */
```
