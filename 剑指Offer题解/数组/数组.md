## [1. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
  const map = new Map();
  for (let num of nums) {
    map.set(num, map.has(num) ? map.get(num) + 1 : 1);
  }
  return map.get(target) || 0;
};
/*
  使用map结构来记录数字在数组中出现的次数
 */
```

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
  let i = 0,
    j = nums.length - 1;
  while (i <= j) {
    let m = Math.floor((i + j) / 2);
    nums[m] <= target ? (i = m + 1) : (j = m - 1);
  }
  let right = i;
  if (j >= 0 && nums[j] !== target) return 0;
  i = 0;
  while (i <= j) {
    let m = Math.floor((i + j) / 2);
    nums[m] >= target ? (j = m - 1) : (i = m + 1);
  }
  let left = j;
  return right - left - 1;
};
/*
  题解：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/
  解题思路： 
    （无序数组先将数组排序），排序数组nums中的所有数字target形成一个窗口，记窗口的左/右边界索引分别为left和right。
    分别对应窗口左边/右边的首个元素。本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 left 
    和 右边界 right ，易得数字 target 的数量为 right - left - 1right−left−1 。
 */
```

## [2. 0 ～ n-1 中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function (nums) {
  let i = 0,
    j = nums.length - 1;
  while (i <= j) {
    let m = Math.floor((i + j) / 2);
    nums[m] === m ? (i = m + 1) : (j = m - 1);
  }
  return i;
};
/*
  题解：https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/mian-shi-ti-53-ii-0n-1zhong-que-shi-de-shu-zi-er-f/
  解题思路： 
    - 排序数组的搜索问题首先想到二分法
    - 根据题意，范围为0~n-1内的n个数字，说明索引和值有对应关系，可以将数组划分为两部分
      左子数组：nums[i] = i;
      右子数组：nums[i] !== i;
      所以缺失的数字就是右子数组的首元素对应的索引
      因此用二分法查找右子数组的首位元素
 */
```

## [3. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function (nums) {
  const map = new Map();
  for (let i of nums) {
    if (map.has(i)) return i;
    else map.set(i, 1);
  }
};
/*
  使用Map结构来记录出现过的值
 */
```

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function (nums) {
  let i = 0;
  while (i < nums.length) {
    if (nums[i] == i) {
      i++;
      continue;
    }
    if (nums[nums[i]] == nums[i]) return nums[i];
    let tmp = nums[i];
    nums[i] = nums[tmp];
    nums[tmp] = tmp;
  }
  return -1;
};
/*
  题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。
  此说明含义：数组元素的 索引 和 值 会有 一对多 的关系。
  算法流程：
    遍历数组 nums ，设索引初始值为 i = 0:
    若 nums[i] = i ： 说明此数字已在对应索引位置，无需交换，因此跳过；
    若 nums[nums[i]] = nums[i] ： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找到一组重复值，返回此值 nums[i] ；
    否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。
    若遍历完毕尚未返回，则返回 -1 。

  from jyd https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/
 */
```

## [4. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

```javascript
/**
 * @param {number[]} numbers
 * @return {number}
 */
var minArray = function (numbers) {
  let i = 0,
    j = numbers.length - 1;
  while (i <= j) {
    let m = Math.floor((i + j) / 2);
    if (numbers[m] > numbers[j]) {
      i = m + 1;
    } else if (numbers[m] < numbers[j]) {
      j = m;
    } else {
      j--;
    }
  }
  return numbers[i];
};
/*
  题解： https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/
 */
```

## [5. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var findNumberIn2DArray = function (matrix, target) {
  if (!matrix.length) return false;
  let [y, x] = [0, matrix[0].length - 1];
  while (y < matrix.length && x >= 0) {
    if (matrix[y][x] === target) return true;
    target < matrix[y][x] ? x-- : y++;
  }
  return false;
};
/*
  题解： https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/
 */
```

## [6. 从上到下打印出二叉树 I](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var levelOrder = function (root) {
  if (!root) return [];
  const queue = [root];
  const res = [];
  while (queue.length) {
    const node = queue.shift();
    res.push(node.val);
    node.left && queue.push(node.left);
    node.right && queue.push(node.right);
  }
  return res;
};
/*
  题解： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/solution/mian-shi-ti-32-i-cong-shang-dao-xia-da-yin-er-ch-4/
  解题思路：
    题目要求的二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。
    BFS 通常借助 队列 的先入先出特性来实现。
  算法流程：
    - 特例处理： 当树的根节点为空，则直接返回空列表 [] ；
    - 初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；
    - BFS 循环： 当队列 queue 为空时跳出；
      - 出队： 队首元素出队，记为 node；
      - 打印： 将 node.val 添加至列表 res 尾部；
      - 添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；
    - 返回值： 返回打印结果列表 res 即可。
 */
```

## [7. 从上到下打印出二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
  if (!root) return [];
  const queue = [root];
  const res = [];
  while (queue.length) {
    const temp = [];
    for (let i = queue.length; i > 0; i--) {
      const node = queue.shift();
      temp.push(node.val);
      node.left && queue.push(node.left);
      node.right && queue.push(node.right);
    }
    res.push(temp);
  }
  return res;
};
/*
  题解： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/
  解题思路：
    1. 特例处理： 当根节点为空，则返回空列表 [] ；
    2. 初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；
    3. BFS 循环： 当队列 queue 为空时跳出；
      1.新建一个临时列表 tmp ，用于存储当前层打印结果；
      2.当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；
        1.出队： 队首元素出队，记为 node；
        2.打印： 将 node.val 添加至 tmp 尾部；
        3.添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；
      3.将当前层结果 tmp 添加入 res 。
    4. 返回值： 返回打印结果列表 res 即可。
 */
```
