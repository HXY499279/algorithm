# 贪心算法

## [分发饼干](https://leetcode.cn/problems/assign-cookies/)

```ts
function findContentChildren(g: number[], s: number[]): number {
  // 将两个数组从小到大排序，尺寸大饼干尽量喂胃口大的孩子
  g.sort((a, b) => a - b);
  s.sort((a, b) => a - b);
  // 孩子数量
  const childLen = g.length;
  // 饼干数量
  const cookieLen = s.length;
  // 定义两个指针从后遍历两个数组
  let curChild = childLen - 1;
  let curCookie = cookieLen - 1;
  // 定义可以吃饱的孩子数量
  let childNum = 0;
  while (curChild >= 0 && curCookie >= 0) {
    if (s[curCookie] >= g[curChild]) {
      // 如果当前饼干可以满足当前小孩胃口，则换下一个饼干和小孩
      curChild--, curCookie--;
      // 小孩数量加一
      childNum++;
    } else {
      // 如果当前饼干不能满足当前小孩胃口，则换下一个小孩
      curChild--;
    }
  }
  return childNum;
}
/* 
  贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
  本题局部最优：用大饼干满足大胃口小孩，避免造成饼干浪费
  本题全局最优：吃饱的小孩数量更多
*/
```

## [摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

```ts
function wiggleMaxLength(nums: number[]): number {
  // 处理特殊情况
  if (nums.length <= 1) return nums.length;
  // 记录有几个单调坡
  let res: number = 0;
  // 定义上一次数值变化和当前数值变化 用来判断是否出现单调坡
  let preDiff = 0,
    curDiff = null;
  // 依次遍历数组，保证连续，因为要记录两个数值之间的变化curDiff，所以 i < nums.length-1
  for (let i = 0; i < nums.length - 1; i++) {
    // 记录当前数值变化
    curDiff = nums[i + 1] - nums[i];
    // 如果当前数值变化和上一个数值变化不同，则出现一个单调坡
    // preDiff===0的情况 用来处理只有一个单调坡时的特殊情况
    if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
      // 记录单调坡
      res++;
      // 储存当前变化
      preDiff = curDiff;
    }
  }
  // 峰值数等于单调坡数加一
  return res + 1;
}
/* 
  贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
  本题局部最优：只找连续的单调坡
  本题全局最优：单调坡越多，峰值就越多，摆动序列就越长
*/
```

## [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```ts
function maxSubArray(nums: number[]): number {
  let result = -Infinity;
  // 子序列连续和
  let sum = 0;
  for (let num of nums) {
    sum += num;
    // 记录和 如果出现更大的值就存下来
    if (sum > result) result = sum;
    // 如果连续和为负数时立即放弃，从下一个数开始重新计和
    if (sum < 0) sum = 0;
  }
  return result;
}
/* 
  贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
  本题局部最优：子序列连续和为负数就重新开始计和
  本题全局最优：取的子序列连续和最大
*/
```

## [买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```ts
function maxProfit(prices: number[]): number {
  let result = 0;
  for (let i = 0; i < prices.length - 1; i++) {
    // 只统计正利润
    result += Math.max(prices[i + 1] - prices[i], 0);
  }
  return result;
}
/* 
  贪心的本质是选择每一阶段的局部最优，从而达到全局最优。

  因为股票可以第一天买入第二天卖出，也可以当天买入当天卖出，也可以当天卖出之前的股票再买入新的股票（保证任何时候只能持有一支股票）
  
  股票价格：7 1 5 3 6 4
  每天利润：-6 4 -2 3 -2
  
  本题局部最优：只找正利润
  本题全局最优：获得最大利润
*/
```

## [跳跃游戏](https://leetcode.cn/problems/jump-game/)

```ts
function canJump(nums: number[]): boolean {
  // 维护一个最远跳跃坐标
  let max = 0;
  // 遍历数组每一个元素并且更新最远跳跃坐标
  for (let i = 0; i < nums.length; i++) {
    // 如果超过最远跳跃坐标 则返回false
    if (i > max) {
      return false;
    }
    // 更新最远跳跃坐标
    max = Math.max(max, i + nums[i]);
    // 如果最远跳跃坐标能够覆盖终点 则返回true
    if (max >= nums.length - 1) {
      return true;
    }
  }
}
/* 
  贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
  本题局部最优：每次取最远跳跃坐标
  本题全局最优：最后得到整体最远跳跃坐标，看是否能到达终点

  从第一个坐标开始依次遍历去更新当前最远跳跃坐标
  如果当前遍历位置超过最远跳跃坐标返回false 
  如果当前最远跳跃坐标可以覆盖终点 则返回true
*/
```

## [跳跃游戏 II](https://leetcode.cn/problems/jump-game/)

```ts
/* 
  贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
  本题局部最优：在可跳范围内挑可以跳最远的坐标去跳跃
  本题全局最优：每次跳最远，就能获得最少跳跃步数到达终点
*/
function jump(nums: number[]): number {
  // 当前可跳跃最远坐标（也是当前可跳跃范围，因为小于最远坐标的地方都可以跳到）
  let curCover = 0;
  // 当前可跳跃范围内可以跳跃的最远坐标
  let nextCover = 0;
  let step = 0;
  for (let i = 0; i < nums.length - 1; i++) {
    // 更新当前范围内可以跳跃的最远坐标
    nextCover = Math.max(nextCover, i + nums[i]);
    // 如果遍历到当前可跳跃范围边界，就更新新的可跳跃范围，并记录一次step代表从这个范围起跳了
    if (i === curCover) {
      curCover = nextCover;
      step++;
    }
  }
  return step;
}
```

## [K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

```ts
function largestSumAfterKNegations(nums: number[], k: number): number {
  // 将数组按照绝对值大小从大到小排序
  nums.sort((a, b) => Math.abs(b) - Math.abs(a));
  // 贪心一：遍历数组将负数转正数
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < 0 && k > 0) {
      nums[i] = -nums[i];
      k--;
    }
  }
  // 贪心二：如果k还有剩余，并且k为奇数，则直接将数组最后一个元素（也是最小的）变为负数，k为偶数不做改变
  if (k > 0 && k % 2 === 1) {
    nums[nums.length - 1] *= -1;
  }
  return nums.reduce((a, b) => a + b);
}
/*
    本题使用贪心算法
    局部贪心：将负数转为整数
    整体贪心：数组和最大

    如果数组全为正后，k不为0呢？这里又有一个贪心
    局部贪心：转换k次数组最小值
    整体贪心：数组和最大

    所以本题有两次贪心
 */
```

## [加油站](https://leetcode.cn/problems/gas-station/)

```ts
function canCompleteCircuit(gas: number[], cost: number[]): number {
  let curSum = 0,
    totalSum = 0,
    start = 0;
  for (let i = 0; i < gas.length; i++) {
    // 这里不单独循环生成rest数组了，直接一起操作
    const rest = gas[i] - cost[i];
    curSum += rest;
    totalSum += rest;
    // 如果curSum小于0，则说明从[start,i]都不能作为开始的起点
    if (curSum < 0) {
      curSum = 0;
      start = i + 1;
    }
  }
  if (totalSum < 0) return -1;
  return start;
}
/* 
    由于一定有一个起点可以跑一圈，所以遍历一次rest数组如果前面没有起点，那么后面一定有起点
    局部最优：当前累加rest数组的和curSum一旦小于0，起始位置至少要是i+1。
    全局最优：找到可以跑一圈的起始位置。
 */
```

## [分发糖果](https://leetcode.cn/problems/candy/)

```ts

```

## [根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

```ts

```

## [柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

```ts
function lemonadeChange(bills: number[]): boolean {
  let five = 0,
    ten = 0;
  for (let bill of bills) {
    if (bill === 5) five++;
    if (bill === 10) {
      five--;
      ten++;
    }
    if (bill === 20) {
      // 贪心点：对于20，优先交出10和5组合，因为5相较于10使用更广泛
      if (ten <= 0) {
        five -= 3;
      } else {
        five--;
        ten--;
      }
    }
    if (five < 0 || ten < 0) return false;
  }
  return true;
}
```
