# 数组与矩阵

## [1.把数组中的 0 移到末尾](https://leetcode-cn.com/problems/move-zeroes/)

```javascript
var moveZeroes = function (nums) {
  // 定义index来计数非0数的个数
  let index = 0;
  for (let item of nums) {
    if (item !== 0) {
      // 判断nums数组中的数字，若不为0则依次放在前面，同时增加index的值
      nums[index++] = item;
    }
  }
  // 根据index的数值和数组的长度，来补齐剩下的0，以此来达到将所有0移动到末尾的效果
  while (index < nums.length) {
    nums[index++] = 0;
  }
};
/* 
  创建变量index，记录数组中的非零数个数
  该代码 nums[index++] = nums[i] 实现了将非零数在原数组上移动到前面和记录非零数的个数
  最后将统计出的非零数的个数与原数组长度进行比较，补充0
*/
```

## [2.改变矩阵维度](https://leetcode-cn.com/problems/reshape-the-matrix/description/)

```javascript
var matrixReshape = function (mat, r, c) {
  const m = mat.length;
  const n = mat[0].length;
  if (m * n != r * c) {
    return mat;
  }
  const ans = new Array(r).fill(0).map(() => new Array(c).fill(0));
  for (let x = 0; x < m * n; ++x) {
    // 从0自增的数X 除以 列数C得到行数，X 求余 列数C 得到列数
    ans[Math.floor(x / c)][x % c] = mat[Math.floor(x / n)][x % n];
  }
  return ans;
};
/* 
  1.通过new Array(r).fill(0).map(() => new Array(c).fill(0));的方式
    创造一个r X c的数组，并且把里面初始化为0
  2.根据两个数组中元素个数相同来进行循环，一对一的进行赋值
    其中[Math.floor(总数 / 行数)][总数 % 行数]的巧妙方式
    解决了不同形状矩阵一对一赋值的问题
*/
```

## [3. 找出数组中最长的连续 1](https://leetcode-cn.com/problems/max-consecutive-ones/description/)

```javascript
var findMaxConsecutiveOnes = function (nums) {
  // 定义一个max来保存连续1的最大长度
  let max = 0;
  // 定义onceCount来计数
  let oneCount = 0;
  for (let item of nums) {
    if (item === 1) {
      // 每当遇见1，就计数一次
      oneCount++;
      // 每一次oneCount加一都得进入判断，因为遇见了0就会重置oneCount,所以要及时将最大oneCount存入max中，
      if (oneCount > max) {
        max = oneCount;
      }
    } else {
      // 如果遇见了0，就停止计数，并重置oneCount
      oneCount = 0;
    }
  }
  return max;
};
/* 

*/
```

## [4. 有序矩阵查找](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/)

```javascript
var searchMatrix = function (matrix, target) {
  if (matrix.length === 0) {
    return false;
  }
  // 以矩阵左上角为移动元素的起始元素，定义变量left和up，并且赋值为起始元素的坐标，
  let [left, up] = [matrix[0].length - 1, 0];
  // 通过while循环，设置循环条件为left,up超过矩阵size的界限
  while (left >= 0 && up < matrix.length) {
    // 通过if else判断target和移动元素的大小，大：up++ 小：left--
    if (target === matrix[up][left]) {
      // 如果相等了，说明找到了，返回true
      return true;
    }
    // 通过三目运算符来代替if else elseif的结构
    target < matrix[up][left] ? left-- : up++;
  }
  return false;
};
/* 

*/
```

<img src="https://pic.leetcode-cn.com/1602309177-SsaQGG-image.png" >

## [5. 有序矩阵的 Kth Element](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)

```javascript
var kthSmallest = function (matrix, k) {
  matrix = matrix.flat();
  matrix.sort((a, b) => {
    return a - b;
  });
  return matrix[k - 1];
};
/* 

*/
```

## [6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数](https://leetcode-cn.com/problems/set-mismatch/description/)

```javascript
var findErrorNums = function (nums) {
  //  初始化错误数组
  let errorNums = new Array(2).fill(0);
  const n = nums.length;
  // 创建Map，利用Map的 1.键可以是任意类型的值 2.相同的键，其值可以覆盖
  const map = new Map();
  for (let item of nums) {
    // 如果item只有一次，则设为1，如果item出现两次，就设为2
    map.set(item, (map.get(item) || 0) + 1);
  }
  for (let i = 1; i <= n; i++) {
    // 使用数组中应该有的数值 1-n 来验证map中的值
    const count = map.get(i) || 0;
    if (count === 2) {
      // 如果是计数两次，就是重复数字
      errorNums[0] = i;
    } else if (count === 0) {
      // 如果是计数零次，就是丢失的数字
      errorNums[1] = i;
    }
  }
  return errorNums;
};
/* 

*/
```

## [7. 找出数组中重复的数，数组值在 [1, n] 之间](https://leetcode-cn.com/problems/find-the-duplicate-number/description/)

```javascript
// HashMap的方式
var findDuplicate = function (nums) {
  let n;
  const map = new Map();
  for (let item of nums) {
    // 将nums里面的内容一个一个存入map的键中，并赋初值为1，若存入重复的键，则将值 +1
    map.set(item, (map.get(item) || 0) + 1);
  }
  for (let i = 1; i <= nums.length; i++) {
    // 最后map循环完的结果就是，重复的数字，其在map中的值为>1
    const count = map.get(i);
    if (count > 1) {
      //通过值>1的找到重复的数字
      n = i;
    }
  }
  return n;
};
// 快慢指针
var findDuplicate = function (nums) {
  let slow = 0,
    fast = 0;
  do {
    slow = nums[slow];
    fast = nums[nums[fast]];
  } while (slow != fast);
  slow = 0;
  while (slow != fast) {
    slow = nums[slow];
    fast = nums[fast];
  }
  return slow;
};

/* 

*/
```

## [8.优美的排列 II](https://leetcode-cn.com/problems/beautiful-arrangement-ii/)

```javascript
var constructArray = function (n, k) {
  // 使用Array的from方法，第一个参数必须传入有length属性的可以迭代的对象，第二个参数是函数类似于map方法
  // 创建长度为n的数组，数组每一项是下标加一，1-n的整数
  const ans = Array.from({ length: n }, (_, i) => i + 1);
  /* 
    for循环的效果：当n=5,k=4时
    [1,2,3,4,5] 
    [1,5,3,4,5] 第二个元素=第一个元素加了k=4
    [1,5,2,4,5] 第三个元素=第二个元素减了k=3
    [1,5,2,4,5] 第四个元素=第三个元素加了k=2
    [1,5,2,4,3] 第五个元素=第四个元素减了k=1
  */
  for (let i = 1, flag = 1; k > 0; i++, flag *= -1, k--) {
    ans[i] = ans[i - 1] + k * flag;
  }
  return ans;
};
/* 

*/
```

## [9.数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

```javascript
// by myself
var findShortestSubArray = function (nums) {
  const map = new Map();
  nums.forEach((item) => {
    // 循环统计nums数组中一个数字出现的次数，将数字和出现次数映射到map结构中
    map.set(item, (map.get(item) || 0) + 1);
  });
  // 获取map中“出现次数”的最大值
  const max = Math.max(...map.values());
  let tags = [];
  map.forEach((item, index) => {
    // 在map中循环找到是哪个数字出现的次数最大
    // 并通过这个数字在nums数组中首次出现和最后次出现的下标来计算获取最小子数组长度
    // 若有多个“出现次数”的最大值,则存入tags数组中
    item === max
      ? tags.push(nums.lastIndexOf(index) - nums.indexOf(index) + 1)
      : -1;
  });
  // 返回tags数组中的最小值
  return Math.min(...tags);
};

// by other
var findShortestSubArray = function (nums) {
  // 创建对象来保存nums数组中的映射结构 num ——> [count,firstIndex,lastIndex]
  const mp = {};
  // nums.entries() 生成nums的[index,item]迭代器
  for (const [i, num] of nums.entries()) {
    if (num in mp /* in运算符判断num属性是否在mp对象中 */) {
      // 多次出现，刷新映射的值
      // 将num的次数加1，刷新num再次出现的下标
      mp[num][0]++;
      mp[num][2] = i;
    } else {
      // 首次出现,建立映射的结构
      // [count, left, right]记录num出现的次数，以及第一次出现的下标，和初始化num再次出现的下标
      mp[num] = [1, i, i];
    }
  }

  let maxNum = 0,
    minLen = 0;
  // 获取每个num的信息：出现次数、首次出现下标、末次出现下标
  for (const [count, left, right] of Object.values(mp)) {
    if (maxNum < count) {
      // 找到出现次数最大的数，用首末次出现下标来计算其长度
      maxNum = count;
      minLen = right - left + 1;
    } else if (maxNum === count) {
      // 如果有多个最大值，则选择其最小长度
      minLen > right - left + 1 ? (minLen = right - left + 1) : -1;
    }
  }
  return minLen;
};
/* 
  by other:
    首先题目意思是：记原数组中出现次数最多的数为 x，那么找到和原数组的度相同的最短连续子
    数组，必然包含了原数组中的全部 x，且两端恰为 x 第一次出现和最后一次出现的位置。
    
    第一个for循环，获取nums数组每个数字的信息
    将nums数组中每个数字出现的次数以及第一次和最后一次出现的下标，映射到对象中
    {
      num1:[count,firstIndex,lastIndex],
      num1:[count,firstIndex,lastIndex]
      ......
    }

    第二个for循环，根据众多信息提取所需
    找到nums出现次数最多的数字，并计算其最短连续子数组的长度，若出现次数最多的数字有多个
    则选择其长度最小的

*/
```
