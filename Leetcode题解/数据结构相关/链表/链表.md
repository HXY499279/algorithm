# 链表

## 单链表

### [1. 环形链表 I](https://leetcode-cn.com/leetbook/read/linked-list/jbex5/)

```javascript
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
  // 定义一个快指针和一个慢指针，他们初始在起始位置head上
  let first = head;
  let slow = head;
  // 判断当快指针到的地方或者快指针到的地方的下一个地方为null时，说明该链表没有环形
  while (first && first.next) {
    // 快指针走两步
    first = first.next.next;
    // 慢指针走一步
    slow = slow.next;
    // 当快指针追上满指针的时候，说明链表有环形
    if (first === slow) {
      return true;
    }
  }
  return false;
};
/* 
  想象一下，有两个速度不同的跑步者。如果他们在直路上行驶，快跑者将首先到达目的地。
  但是，如果它们在圆形跑道上跑步，那么快跑者如果继续跑步就会追上慢跑者。

  这正是我们在链表中使用两个速度不同的指针时会遇到的情况
  ：1.如果没有环，快指针将停在链表的末尾。
    2.如果有环，快指针最终将与慢指针相遇。
  所以剩下的问题是这两个指针的适当速度应该是多少？
  ：一个安全的选择是每次移动慢指针一步，而移动快指针两步。每一次迭代，快速指针将
    额外移动一步。如果环的长度为 M，经过 M 次迭代后，快指针肯定会多绕环一周，并
    赶上慢指针。
*/
```

### [2. 环形链表 II](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```javascript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  let fast = head;
  let slow = head;
  while (fast && fast.next) {
    fast = fast.next.next;
    slow = slow.next;
    if (fast === slow) {
      break;
    }
  }
  if (!fast || !fast.next) {
    return null;
  }
  fast = head;
  while (fast !== slow) {
    fast = fast.next;
    slow = slow.next;
  }
  return fast;
};
/* 

*/
```

<img src="https://pic.leetcode-cn.com/1623750708-inrvVm-1623750459597.jpg" />

### [3. 相交链表](https://leetcode-cn.com/leetbook/read/linked-list/jjbj2/)

```javascript
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
  //创造两条组合链接的新链表：A->B，B->A
  let la = headA;
  let lb = headB;
  // 当两套新链表相等时退出循环
  while (la !== lb) {
    // 当la或lb到链表末尾时开始链接另一条链表
    la = la ? la.next : headB;
    lb = lb ? lb.next : headA;
  }
  // 若因为循环判断相等后退出则la为相交节点，若因为
  return la;
};
/* 
  因为相交链表，相交后的部分完全一样，所以可以通过判断链表AB中节点相等来找到相交的地方
  但是链表AB可能长度不相等，那么在长度不相等的情况下如何来实现一对一的判断链表AB节点相等呢？
  ：因为两条链表未相交的地方的节点一定不相等，可以在链表A后链接一个链表B，在链表B后面
    链接一个链表A，这样新生成的两条链表等长度了，并且是在同一个位置开始的节点一对一相等，
    这样我们就可以通过一个循环，两条链表的节点一对一相等判断来找到相交点
*/
```

<img src="https://pic.leetcode-cn.com/1623763419-NdlZHd-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-LeetCode-T1.png" />

### [4. 删除链表的倒数第 N 个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```javascript
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
  // 给head节点前添加一个新的节点
  let pre = new ListNode();
  pre.next = head;
  // 将快慢指针移动到pre上
  let fast = pre;
  let slow = pre;
  // 让快指针先走n步
  for (let i = 0; i < n; i++) {
    fast = fast.next;
  }
  // 快慢指针开始同步走，当快指针到达链表尾部时退出循环，这时候慢指针在待删除节点的前一个位置上
  while (fast.next) {
    fast = fast.next;
    slow = slow.next;
  }
  // 将慢指针与待删除节点下一个节点连接起来
  slow.next = slow.next.next;
  // 返回pre的下一个位置，不能返回head，因为当链表只有一个节点时，head的val还没有被操作到，返回head会出错
  return pre.next;
};
/* 
  by myself:
    循环两次，第一次求出链表长度，第二次循环直接将指针移动到待删除的位置，然后执行删除操作
  by other:
    使用快慢指针，快指针先移动n步，然后再跟慢指针同步移动，当快指针到链表尾部时，慢指针的下
    一个节点就是待删除的节点。其中值得注意的是，当链表只有一个节点的时候是特殊情况，不适用
    快慢指针，但如果还是要结合快慢    指针方法，我们可以给head节点前面再加一个pre节点，将快
    慢指针初始位置移动到pre上来解决特殊情况
*/
```

### [5. 反转链表](https://leetcode-cn.com/leetbook/read/linked-list/f58sg/)

```javascript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  // pre是新的链表头，cur是待反转的节点
  let pre = null,
    cur = head;
  // 创建变量存储待反转节点的下一个节点，以待下一次反转
  let next;
  // 当待反转的节点为null，说明反转完成退出循环
  while (cur) {
    let next = cur.next;
    // 将待反转节点连接到已反转链表头
    cur.next = pre;
    // 将pre和cur往后移一位，进行下一次反转，
    pre = cur;
    cur = next;
  }
  return pre;
};
/* 
  
*/
```

### [6. 移除链表元素](https://leetcode-cn.com/leetbook/read/linked-list/f9izv/)

```javascript
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function (head, val) {
  // 给head节点创建一个前置节点
  let tag = new ListNode();
  tag.next = head;
  let pre = tag,
    cur = head;
  while (cur) {
    // 如果当前节点是待删除节点，就删除
    if (cur.val === val) {
      pre.next = cur.next;
      cur = cur.next;
    } else {
      // 否则就向后移动
      pre = cur;
      cur = cur.next;
    }
  }
  return tag.next;
};
/* 
  给链表创建一个前置节点，便于操作
*/
```

### [7. 奇偶链表](https://leetcode-cn.com/leetbook/read/linked-list/fe0kj/)

```javascript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function (head) {
  // 定义两个指针指向head和head的下一节点
  let cur1 = head,
    // 由于会出现head = null的情况，所以使用?.的方式避免错误
    cur2 = head?.next;
  if (!cur1) {
    return head;
  }
  // 创建变量tag来存储偶数链的头部节点，以便于后续连接在奇数链的末尾
  const tag = head.next;
  // 当下一个节点为null时，说明链表每一个节点已经遍历完成
  // 且cur1和cur2都分别在奇偶链末尾可以退出循环了
  while (cur1.next && cur2.next) {
    // 将奇偶位上的节点连接起来
    cur1.next = cur1.next.next;
    cur1 = cur1.next;
    cur2.next = cur2.next.next;
    cur2 = cur2.next;
  }
  // 将奇数链的末尾连接上偶数链
  cur1.next = tag;
  return head;
};
/* 
  
*/
```

### [8. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```javascript
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
  let len = 0,
    cur = head;
  // 获取链表的长度，存入len中
  while (cur) {
    cur = cur.next;
    len++;
  }
  // 将cur移动回原位head
  cur = head;
  // 将前半部分链表反转
  let next = null,
    pre = null;
  for (let i = 0; i < Math.floor(len / 2); i++) {
    next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  // 判断链表长度为奇数还是偶数
  if (len % 2 === 0) {
    while (pre && cur) {
      if (pre.val !== cur.val) {
        return false;
      }
      pre = pre.next;
      cur = cur.next;
    }
  } else {
    // 如果是偶数，就把cur移动到下一位
    cur = cur.next;
    while (pre && cur) {
      if (pre.val !== cur.val) {
        return false;
      }
      pre = pre.next;
      cur = cur.next;
    }
  }
  return true;
};
/* 
  1. 找到链表长度
  2. 将链表的前一半进行反转
  3. 中间开花，指针向两端走，一对一判断是否相等（注意链表长度的奇偶）
*/
```

<img src= "https://pic.leetcode-cn.com/1632624852-AreVHM-0%251A%5B%25E11~6331KEYA0VHDH.png"/>

### [9. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```javascript
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */

// 该mergeTwoLists函数的作用就是返回两个节点中的最小节点
var mergeTwoLists = function (l1, l2) {
  // 当l1或者l2为null时，直接返回另一条剩下的全部节点
  if (!l1) {
    return l2;
  }
  if (!l2) {
    return l1;
  }
  if (l1.val < l2.val) {
    // 当l1节点的值小于l2节点的值时，用l1去连接 l1下一节点和l2中的最小值，下面同理
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
var mergeTwoLists = function (l1, l2) {
  //创建一个dummy头节点和一个当前节点cur
  let dummy = new ListNode(),
    cur = dummy;
  // 如果l1和l2有一个为null则退出循环
  while (l1 && l2) {
    if (l1.val < l2.val) {
      // 当l1节点的值小于l2节点的值时，将cur节点连接到l1节点，并把l1节点往后移一位，下面同理
      cur.next = l1;
      l1 = l1.next;
    } else {
      cur.next = l2;
      l2 = l2.next;
    }
    // 再把cur节点向后移动一位
    cur = cur.next;
  }
  // 当l1或l2有一个为null时，cur连接另一个链
  cur.next = l1 ? l1 : l2;
  // 返回dummy节点的下一个节点
  return dummy.next;
};

/* 
  方法一：
    通过递归的方式
  方法二：
    给合并链表添加一个dummy节点，定义一个cur指向dummy节点，cur的next连接两个链表的最小节点
    本题通过三个指针的方式：cur l1 l2 来进行解答
*/
```

### [10. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```javascript
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
  // 创建第三条节点的虚拟dummy节点头
  const dummy = new ListNode();
  // 创建变量cur指向虚拟头节点，创建carry来存储进位数，创建sum来储存求和数
  let cur = dummy,
    carry = 0,
    sum = 0;
  // 当l1 l2为null carry为0 的时候退出循环
  while (l1 || l2 || carry) {
    // 每次循环一开始将sum清零
    sum = 0;
    // 当一条链表的节点为null时，设置其值为0
    sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry;
    // carry使用过后清零
    carry = 0;
    // 当一次求和的sum大于10时，要进行进位操作，将进位数给到carry，sum取个位
    carry = Math.floor(sum / 10);
    sum = sum % 10;
    // 将cur的下一个节点赋值成一个新的 值为sum的节点
    cur.next = new ListNode(sum);
    // 如果l1,l2存在时，会进行进位
    if (l1 != null) {
      l1 = l1.next;
    }
    if (l2 != null) {
      l2 = l2.next;
    }
    cur = cur.next;
  }
  return dummy.next;
};

/* 
  两数之和，通过构造第三条链表，来存储l1,l2链表的求和数，注意进位和两条链表长度不对等的问题
*/
```

### [11. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

```javascript
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var rotateRight = function (head, k) {
  // 定义count计算链表的长度
  let count = 0,
    cur = head;
  // 如果链表没有节点，就直接返回
  if (!head) {
    return head;
  }
  // 通过循环将cur移动到链表的最后一个节点
  while (cur.next) {
    cur = cur.next;
    count++;
  }
  // 因为循环退出条件是cur.next等于null，所以此时count比真实的链表长度小1
  count++;
  // 如果K等于链表长度，就直接把链表返回
  if (k === count) {
    return head;
  }
  // 将链表末尾连接到头节点
  cur.next = head;
  // 再将cur放置在头节点
  cur = head;
  // 将K修改成从头节点出发到达要断开节点的步数
  k = count - (k % count) - 1; // 其中当K大于链表长度时，就出现了循环，循环相当于什么都没变
  // 移动cur到要断开的地方
  for (let i = 0; i < k; i++) {
    cur = cur.next;
  }
  // 存储cur的下一个节点，当作新链表的头节点
  const ret = cur.next;
  // 断开cur与下一个节点之间的连接
  cur.next = null;
  return ret;
};

/* 
  根据题目意思简化解题思路：一连，二断，三考虑
    1.找到链表长度的同时将末尾节点连接到头节点
    2.找到要断开链表的地方，也就是新链表的末尾节点和头节点连接的地方
    3.考虑边值情况，例如链表为空，K等于链表长度
*/
```

### [12. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

```javascript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function (head) {
  let cur = head;
  while (cur?.next) {
    if (cur.val === cur.next.val) {
      // 如果当前节点和下一个节点值相等,就把当前节点连接到下下个节点
      cur.next = cur.next.next;
    } else {
      // 如果不相等就移位
      cur = cur.next;
    }
  }
  return head;
};

/* 

*/
```

### [13. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```javascript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
// 迭代
var swapPairs = function (head) {
  // 创建dummy节点，将节点两两之间的关系更改成三三之间的关系
  let dummyHead = new ListNode(),
    temp;
  dummyHead.next = head;
  temp = dummyHead;
  // 当temp的下一个节点和下下个节点都不为null时，才能进行交换
  while (temp.next !== null && temp.next.next !== null) {
    // 从 temp->node1->node2 到 temp->node2->node1
    const node1 = temp.next;
    const node2 = temp.next.next;
    temp.next = node2;
    node1.next = node2.next;
    node2.next = node1;
    // 将temp移动到node1的位置
    temp = node1;
  }
  return dummyHead.next;
};
// 递归
var swapPairs = function (head) {
  if (head === null || head.next === null) {
    return head;
  }
  let next = head.next;
  head.next = swapPairs(next.next);
  next.next = head;
  return next;
};
/* 

*/
```
<a href="https://lyl0724.github.io/2020/01/25/1/">递归参考</a>

## 双链表

### [1. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/solution/)

```javascript
/**·
 * @param {Node} head
 * @return {Node}
 */
var flatten = function (head) {
  // 当链表为空时，直接返回空链表
  if (head === null) {
    return head;
  }
  let cur = head;
  // 定义一个temp数组来储存右节点
  const temp = [];
  // 定义一个count来计算temp里面右节点的个数
  let count = 0;
  // 当一个节点没有next节点并且没有child节点并且count也为0
  // (count为0,说明没有上一级的右节点需要连接)时,说明此时cur在最后一个节点上
  while (cur.next !== null || count !== 0 || cur.child !== null) {
    // 如果该节点有child节点(左节点),此时就需要把child节点扁平化,开始遍历连接左节点
    if (cur.child) {
      // 如果有右节点,就把右节点存储在temp中,便于后续连接
      if (cur.next !== null) {
        count++;
        temp[count] = cur.next;
      }
      // 将cur节点和child节点之间的连接改成双链表连接
      cur.next = cur.child;
      cur.child.prev = cur;
      // 要把child节点设为null,才是一个合理的双向链表,双向链表不能有分支
      cur.child = null;
    }
    // 如果左节点到头了,并且count不为0,也就是有右节点时,就开始连接右节点
    if (cur.next === null && count !== 0) {
      cur.next = temp[count];
      // 将child单链变成双链
      temp[count].prev = cur;
      count--;
    }
    // 将cur指针移位
    cur = cur.next;
  }
  return head;
};
/* 
  将多级链表抽象看成树的结构,通过前序遍历(根左右)来进行链表扁平化,如下图
  
  从中间根节点开始遍历,然后是左节点,然后右节点,注意从根节点遍历到左节点时
  如果有右节点,要将右节点存在temp数组里面,并且用count记录个数
  当左节点的next为nul时,说明左节点遍历完成,然后从下到上遍历右节点

  注意界值问题
*/
```

<img src="https://pic.leetcode-cn.com/1622041357-JQLhyA-%E6%97%A0%E6%A0%87%E9%A2%98.png">
