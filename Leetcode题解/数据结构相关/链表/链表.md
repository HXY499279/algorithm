# 链表

## [1. 环形链表 I](https://leetcode-cn.com/leetbook/read/linked-list/jbex5/)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
  // 定义一个快指针和一个慢指针，他们初始在起始位置head上
  let first = head;
  let slow = head;
  // 判断当快指针到的地方或者快指针到的地方的下一个地方为null时，说明该链表没有环形
  while (first && first.next) {
    // 快指针走两步
    first = first.next.next;
    // 慢指针走一步
    slow = slow.next;
    // 当快指针追上满指针的时候，说明链表有环形
    if (first === slow) {
      return true;
    }
  }
  return false;
};
/* 
  想象一下，有两个速度不同的跑步者。如果他们在直路上行驶，快跑者将首先到达目的地。
  但是，如果它们在圆形跑道上跑步，那么快跑者如果继续跑步就会追上慢跑者。

  这正是我们在链表中使用两个速度不同的指针时会遇到的情况
  ：1.如果没有环，快指针将停在链表的末尾。
    2.如果有环，快指针最终将与慢指针相遇。
  所以剩下的问题是这两个指针的适当速度应该是多少？
  ：一个安全的选择是每次移动慢指针一步，而移动快指针两步。每一次迭代，快速指针将
    额外移动一步。如果环的长度为 M，经过 M 次迭代后，快指针肯定会多绕环一周，并
    赶上慢指针。
*/
```

## [2. 环形链表 II](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  let fast = head;
  let slow = head;
  while (fast && fast.next) {
    fast = fast.next.next;
    slow = slow.next;
    if (fast === slow) {
      break;
    }
  }
  if (!fast || !fast.next) {
    return null;
  }
  fast = head;
  while (fast !== slow) {
    fast = fast.next;
    slow = slow.next;
  }
  return fast;
};
/* 

*/
```

<img src="https://pic.leetcode-cn.com/1623750708-inrvVm-1623750459597.jpg" />

## [3. 相交链表](https://leetcode-cn.com/leetbook/read/linked-list/jjbj2/)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
  //创造两条组合链接的新链表：A->B，B->A
  let la = headA;
  let lb = headB;
  // 当两套新链表相等时退出循环
  while (la !== lb) {
    // 当la或lb到链表末尾时开始链接另一条链表
    la = la ? la.next : headB;
    lb = lb ? lb.next : headA;
  }
  // 若因为循环判断相等后退出则la为相交节点，若因为
  return la;
};
/* 
  因为相交链表，相交后的部分完全一样，所以可以通过判断链表AB中节点相等来找到相交的地方
  但是链表AB可能长度不相等，那么在长度不相等的情况下如何来实现一对一的判断链表AB节点相等呢？
  ：因为两条链表未相交的地方的节点一定不相等，可以在链表A后链接一个链表B，在链表B后面
    链接一个链表A，这样新生成的两条链表等长度了，并且是在同一个位置开始的节点一对一相等，
    这样我们就可以通过一个循环，两条链表的节点一对一相等判断来找到相交点
*/
```

<img src="https://pic.leetcode-cn.com/1623763419-NdlZHd-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-LeetCode-T1.png" />

## [4. 删除链表的第N个节点](https://leetcode-cn.com/leetbook/read/linked-list/jf1cc/)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
  // 给head节点前添加一个新的节点
  let pre = new ListNode();
  pre.next = head;
  // 将快慢指针移动到pre上
  let fast = pre;
  let slow = pre;
  // 让快指针先走n步
  for (let i = 0; i < n; i++) {
    fast = fast.next;
  }
  // 快慢指针开始同步走，当快指针到达链表尾部时退出循环，这时候慢指针在待删除节点的前一个位置上
  while (fast.next) {
    fast = fast.next;
    slow = slow.next;
  }
  // 将慢指针与待删除节点下一个节点连接起来
  slow.next = slow.next.next;
  // 返回pre的下一个位置，不能返回head，因为当链表只有一个节点时，head的val还没有被操作到，返回head会出错
  return pre.next;
};
/* 
  by myself:
    循环两次，第一次求出链表长度，第二次循环直接将指针移动到待删除的位置，然后执行删除操作
  by other:
    使用快慢指针，快指针先移动n步，然后再跟慢指针同步移动，当快指针到链表尾部时，慢指针的下
    一个节点就是待删除的节点。其中值得注意的是，当链表只有一个节点的时候是特殊情况，不适用
    快慢指针，但如果还是要结合快慢    指针方法，我们可以给head节点前面再加一个pre节点，将快
    慢指针初始位置移动到pre上来解决特殊情况
*/
```
